{
  "language": "Solidity",
  "sources": {
    "contracts/interfaces/ISpendPermissionManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/**\n * @title ISpendPermissionManager\n * @notice Interface for Coinbase's SpendPermissionManager contract\n * @dev Deployed on Base Sepolia at 0xf85210B21cC50302F477BA56686d2019dC9b67Ad\n */\ninterface ISpendPermissionManager {\n    /// @notice A spend permission for an external entity to spend an account's tokens.\n    struct SpendPermission {\n        address account;      // Smart account this permission is valid for\n        address spender;      // Entity that can spend account's tokens\n        address token;        // Token address (ERC-7528 native token or ERC-20)\n        uint160 allowance;    // Maximum allowed value to spend within each period\n        uint48 period;        // Time duration for resetting allowance (seconds)\n        uint48 start;         // Start timestamp (inclusive, unix seconds)\n        uint48 end;           // End timestamp (exclusive, unix seconds)\n        uint256 salt;         // Arbitrary data for uniqueness\n        bytes extraData;      // Arbitrary data for the spender\n    }\n\n    /// @notice Period parameters and spend usage.\n    struct PeriodSpend {\n        uint48 start;    // Period start timestamp\n        uint48 end;      // Period end timestamp\n        uint160 spend;   // Accumulated spend for the period\n    }\n\n    /// @notice Approve a spend permission via a signature from the account.\n    /// @param spendPermission Details of the spend permission.\n    /// @param signature Signed approval from the user.\n    /// @return approved True if spend permission is approved and not revoked.\n    function approveWithSignature(\n        SpendPermission calldata spendPermission,\n        bytes calldata signature\n    ) external returns (bool);\n\n    /// @notice Spend tokens using a spend permission.\n    /// @dev Reverts if not called by the spender of the spend permission.\n    /// @param spendPermission Details of the spend permission.\n    /// @param value Amount of token attempting to spend.\n    function spend(SpendPermission memory spendPermission, uint160 value) external;\n\n    /// @notice Get if a spend permission is approved.\n    /// @param spendPermission Details of the spend permission.\n    /// @return approved True if spend permission is approved.\n    function isApproved(SpendPermission memory spendPermission) external view returns (bool);\n\n    /// @notice Get the unique hash for a spend permission.\n    /// @param spendPermission Details of the spend permission.\n    /// @return hash Unique hash.\n    function getHash(SpendPermission memory spendPermission) external view returns (bytes32);\n\n    /// @notice Get the last updated period for a spend permission.\n    /// @param spendPermission Details of the spend permission.\n    /// @return lastUpdatedPeriod The last updated period with spend usage.\n    function getLastUpdatedPeriod(SpendPermission memory spendPermission) external view returns (PeriodSpend memory);\n}\n"
    },
    "contracts/LumoContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"./interfaces/ISpendPermissionManager.sol\";\n\n/**\n * @title IERC20\n * @notice Minimal ERC20 interface for token transfers\n */\ninterface IERC20 {\n    function transfer(address to, uint256 amount) external returns (bool);\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n    function balanceOf(address account) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n}\n\n/**\n * @title LumoContract\n * @notice Main contract for Lumo SIP (Systematic Investment Plan) DeFAI automation\n * @dev Uses Coinbase's SpendPermissionManager for automated USDC deposits\n *      SIP investments use USDC, Agent payments use ETH\n */\ncontract LumoContract {\n    struct Strategy {\n        uint8 aavePercent;\n        uint8 compoundPercent;\n        uint8 uniswapPercent;\n    }\n\n    struct SIPPlan {\n        address user;\n        uint256 planId;           // Database plan ID for reference\n        uint256 monthlyAmount;    // Amount in USDC (6 decimals)\n        Strategy strategy;\n        uint256 totalDeposited;\n        uint256 lastDepositTime;\n        uint256 createdAt;\n        bool active;\n        bool rebalancingEnabled;  // Whether AI rebalancing is enabled\n    }\n\n    // User address => Plan ID => SIPPlan (users can have multiple plans)\n    mapping(address => mapping(uint256 => SIPPlan)) public userPlans;\n    // User address => array of plan IDs\n    mapping(address => uint256[]) public userPlanIds;\n    \n    address public aave;\n    address public compound;\n    address public uniswap;\n    address public owner;\n    \n    // USDC token address on Base Sepolia\n    address public constant USDC = 0x036CbD53842c5426634e7929541eC2318f3dCF7e;\n    \n    // Native ETH address constant (ERC-7528)\n    address public constant NATIVE_ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    \n    // Expert agent address for AI payments\n    address public expertAgentAddress;\n    \n    // SpendPermissionManager contract address (Base Sepolia)\n    ISpendPermissionManager public spendPermissionManager;\n\n    event SIPCreated(address indexed user, uint256 indexed planId, uint256 monthlyAmount);\n    event DepositExecuted(address indexed user, uint256 indexed planId, uint256 amount);\n    event FundsAllocated(address indexed protocol, uint256 amount);\n    event PlanCancelled(address indexed user, uint256 indexed planId);\n    event PlanPaused(address indexed user, uint256 indexed planId);\n    event PlanResumed(address indexed user, uint256 indexed planId);\n    event PlanRebalanced(address indexed user, uint256 indexed planId, uint8 aavePercent, uint8 compoundPercent, uint8 uniswapPercent);\n    event AgentPaymentExecuted(address indexed user, address indexed agent, uint256 amount);\n    event ExpertAgentAddressUpdated(address indexed oldAddress, address indexed newAddress);\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only owner\");\n        _;\n    }\n\n    constructor(\n        address _aave, \n        address _compound, \n        address _uniswap,\n        address _spendPermissionManager\n    ) {\n        aave = _aave;\n        compound = _compound;\n        uniswap = _uniswap;\n        spendPermissionManager = ISpendPermissionManager(_spendPermissionManager);\n        owner = msg.sender;\n    }\n\n    /**\n     * @notice Create a new SIP plan for a user\n     * @dev This is called by the frontend when user confirms their plan\n     * @param planId The database plan ID for reference\n     * @param monthlyAmount Monthly investment amount in USDC (6 decimals)\n     * @param aavePercent Percentage allocation to Aave\n     * @param compoundPercent Percentage allocation to Compound\n     * @param uniswapPercent Percentage allocation to Uniswap\n     * @param enableRebalancing Whether to enable AI rebalancing\n     */\n    function createSIPPlan(\n        uint256 planId,\n        uint256 monthlyAmount,\n        uint8 aavePercent,\n        uint8 compoundPercent,\n        uint8 uniswapPercent,\n        bool enableRebalancing\n    ) external {\n        require(monthlyAmount > 0, \"Monthly amount must be greater than 0\");\n        require(aavePercent + compoundPercent + uniswapPercent == 100, \"Percents must sum to 100\");\n        require(userPlans[msg.sender][planId].createdAt == 0, \"Plan already exists\");\n\n        Strategy memory strategy = Strategy({\n            aavePercent: aavePercent,\n            compoundPercent: compoundPercent,\n            uniswapPercent: uniswapPercent\n        });\n\n        userPlans[msg.sender][planId] = SIPPlan({\n            user: msg.sender,\n            planId: planId,\n            monthlyAmount: monthlyAmount,\n            strategy: strategy,\n            totalDeposited: 0,\n            lastDepositTime: 0,\n            createdAt: block.timestamp,\n            active: true,\n            rebalancingEnabled: enableRebalancing\n        });\n\n        userPlanIds[msg.sender].push(planId);\n\n        emit SIPCreated(msg.sender, planId, monthlyAmount);\n    }\n\n    /**\n     * @notice Create a new SIP plan (backwards compatible - no rebalancing param)\n     */\n    function createSIPPlan(\n        uint256 planId,\n        uint256 monthlyAmount,\n        uint8 aavePercent,\n        uint8 compoundPercent,\n        uint8 uniswapPercent\n    ) external {\n        require(monthlyAmount > 0, \"Monthly amount must be greater than 0\");\n        require(aavePercent + compoundPercent + uniswapPercent == 100, \"Percents must sum to 100\");\n        require(userPlans[msg.sender][planId].createdAt == 0, \"Plan already exists\");\n\n        Strategy memory strategy = Strategy({\n            aavePercent: aavePercent,\n            compoundPercent: compoundPercent,\n            uniswapPercent: uniswapPercent\n        });\n\n        userPlans[msg.sender][planId] = SIPPlan({\n            user: msg.sender,\n            planId: planId,\n            monthlyAmount: monthlyAmount,\n            strategy: strategy,\n            totalDeposited: 0,\n            lastDepositTime: 0,\n            createdAt: block.timestamp,\n            active: true,\n            rebalancingEnabled: false\n        });\n\n        userPlanIds[msg.sender].push(planId);\n\n        emit SIPCreated(msg.sender, planId, monthlyAmount);\n    }\n\n    /**\n     * @notice Execute a USDC deposit for a user's SIP plan using spend permission\n     * @dev Called by the server wallet (spender) using the stored spend permission\n     * @param user The user whose SIP is being executed\n     * @param planId The plan ID to execute\n     * @param spendPermission The spend permission struct (must be for USDC token)\n     * @param signature The user's signature for the spend permission\n     * @param amount Amount to deposit in this execution (USDC, 6 decimals)\n     */\n    function executeDepositUSDC(\n        address user,\n        uint256 planId,\n        ISpendPermissionManager.SpendPermission calldata spendPermission,\n        bytes calldata signature,\n        uint160 amount\n    ) external onlyOwner {\n        SIPPlan storage plan = userPlans[user][planId];\n        require(plan.active, \"No active plan\");\n        require(plan.user == user, \"User mismatch\");\n        require(spendPermission.account == user, \"Permission account mismatch\");\n        require(spendPermission.spender == msg.sender, \"Spender mismatch\");\n        require(spendPermission.token == USDC, \"Token must be USDC\");\n\n        // First, approve the spend permission on-chain if not already approved\n        if (!spendPermissionManager.isApproved(spendPermission)) {\n            spendPermissionManager.approveWithSignature(spendPermission, signature);\n        }\n\n        // Execute the spend - this transfers USDC from user to this contract\n        spendPermissionManager.spend(spendPermission, amount);\n\n        // Now allocate the received USDC to protocols\n        _allocateFundsUSDC(plan, amount);\n\n        plan.totalDeposited += amount;\n        plan.lastDepositTime = block.timestamp;\n\n        emit DepositExecuted(user, planId, amount);\n    }\n\n    /**\n     * @notice Execute a deposit for a user's SIP plan using spend permission (backwards compatible - ETH)\n     * @dev Called by the server wallet (spender) using the stored spend permission\n     */\n    function executeDeposit(\n        address user,\n        uint256 planId,\n        ISpendPermissionManager.SpendPermission calldata spendPermission,\n        bytes calldata signature,\n        uint160 amount\n    ) external onlyOwner {\n        SIPPlan storage plan = userPlans[user][planId];\n        require(plan.active, \"No active plan\");\n        require(plan.user == user, \"User mismatch\");\n        require(spendPermission.account == user, \"Permission account mismatch\");\n        require(spendPermission.spender == msg.sender, \"Spender mismatch\");\n\n        // First, approve the spend permission on-chain if not already approved\n        if (!spendPermissionManager.isApproved(spendPermission)) {\n            spendPermissionManager.approveWithSignature(spendPermission, signature);\n        }\n\n        // Execute the spend - this transfers tokens from user to this contract\n        spendPermissionManager.spend(spendPermission, amount);\n\n        // Now allocate the received funds to protocols\n        _allocateFunds(plan, amount);\n\n        plan.totalDeposited += amount;\n        plan.lastDepositTime = block.timestamp;\n\n        emit DepositExecuted(user, planId, amount);\n    }\n\n    /**\n     * @notice Execute a direct ETH deposit (for users who send ETH directly)\n     * @dev Alternative method for direct deposits without spend permissions\n     * @param planId The plan ID to fund\n     */\n    function depositDirect(uint256 planId) external payable {\n        SIPPlan storage plan = userPlans[msg.sender][planId];\n        require(plan.active, \"No active plan\");\n        require(msg.value > 0, \"Must send ETH\");\n\n        _allocateFunds(plan, msg.value);\n\n        plan.totalDeposited += msg.value;\n        plan.lastDepositTime = block.timestamp;\n\n        emit DepositExecuted(msg.sender, planId, msg.value);\n    }\n\n    /**\n     * @notice Rebalance a user's SIP plan with new strategy allocation\n     * @dev Called by the server after AI generates new strategy\n     * @param user The user whose plan is being rebalanced\n     * @param planId The plan ID to rebalance\n     * @param newAavePercent New percentage allocation to Aave\n     * @param newCompoundPercent New percentage allocation to Compound\n     * @param newUniswapPercent New percentage allocation to Uniswap\n     */\n    function rebalance(\n        address user,\n        uint256 planId,\n        uint8 newAavePercent,\n        uint8 newCompoundPercent,\n        uint8 newUniswapPercent\n    ) external onlyOwner {\n        SIPPlan storage plan = userPlans[user][planId];\n        require(plan.active, \"No active plan\");\n        require(plan.user == user, \"User mismatch\");\n        require(plan.rebalancingEnabled, \"Rebalancing not enabled\");\n        require(newAavePercent + newCompoundPercent + newUniswapPercent == 100, \"Percents must sum to 100\");\n\n        plan.strategy.aavePercent = newAavePercent;\n        plan.strategy.compoundPercent = newCompoundPercent;\n        plan.strategy.uniswapPercent = newUniswapPercent;\n\n        emit PlanRebalanced(user, planId, newAavePercent, newCompoundPercent, newUniswapPercent);\n    }\n\n    /**\n     * @notice Toggle rebalancing for a plan\n     * @param planId The plan ID\n     * @param enabled Whether to enable rebalancing\n     */\n    function setRebalancing(uint256 planId, bool enabled) external {\n        SIPPlan storage plan = userPlans[msg.sender][planId];\n        require(plan.createdAt > 0, \"Plan does not exist\");\n        require(plan.user == msg.sender, \"Not plan owner\");\n        \n        plan.rebalancingEnabled = enabled;\n    }\n\n    /**\n     * @notice Internal function to allocate USDC funds to protocols based on strategy\n     */\n    function _allocateFundsUSDC(SIPPlan storage plan, uint256 amount) internal {\n        // Calculate amounts for each protocol\n        uint256 aaveAmount = (amount * plan.strategy.aavePercent) / 100;\n        uint256 compoundAmount = (amount * plan.strategy.compoundPercent) / 100;\n        uint256 uniswapAmount = (amount * plan.strategy.uniswapPercent) / 100;\n\n        IERC20 usdc = IERC20(USDC);\n\n        // Transfer USDC to protocols\n        if (aaveAmount > 0) {\n            require(usdc.transfer(aave, aaveAmount), \"Aave transfer failed\");\n            emit FundsAllocated(aave, aaveAmount);\n        }\n\n        if (compoundAmount > 0) {\n            require(usdc.transfer(compound, compoundAmount), \"Compound transfer failed\");\n            emit FundsAllocated(compound, compoundAmount);\n        }\n\n        if (uniswapAmount > 0) {\n            require(usdc.transfer(uniswap, uniswapAmount), \"Uniswap transfer failed\");\n            emit FundsAllocated(uniswap, uniswapAmount);\n        }\n    }\n\n    /**\n     * @notice Internal function to allocate ETH funds to protocols based on strategy\n     */\n    function _allocateFunds(SIPPlan storage plan, uint256 amount) internal {\n        // Calculate amounts for each protocol\n        uint256 aaveAmount = (amount * plan.strategy.aavePercent) / 100;\n        uint256 compoundAmount = (amount * plan.strategy.compoundPercent) / 100;\n        uint256 uniswapAmount = (amount * plan.strategy.uniswapPercent) / 100;\n\n        // Send to mock protocols\n        if (aaveAmount > 0) {\n            (bool success1, ) = aave.call{value: aaveAmount}(\"\");\n            require(success1, \"Aave deposit failed\");\n            emit FundsAllocated(aave, aaveAmount);\n        }\n\n        if (compoundAmount > 0) {\n            (bool success2, ) = compound.call{value: compoundAmount}(\"\");\n            require(success2, \"Compound deposit failed\");\n            emit FundsAllocated(compound, compoundAmount);\n        }\n\n        if (uniswapAmount > 0) {\n            (bool success3, ) = uniswap.call{value: uniswapAmount}(\"\");\n            require(success3, \"Uniswap deposit failed\");\n            emit FundsAllocated(uniswap, uniswapAmount);\n        }\n    }\n\n    /**\n     * @notice Get a user's SIP plan\n     */\n    function getPlan(address user, uint256 planId) external view returns (SIPPlan memory) {\n        return userPlans[user][planId];\n    }\n\n    /**\n     * @notice Get all plan IDs for a user\n     */\n    function getUserPlanIds(address user) external view returns (uint256[] memory) {\n        return userPlanIds[user];\n    }\n\n    /**\n     * @notice Cancel a SIP plan\n     */\n    function cancelPlan(uint256 planId) external {\n        SIPPlan storage plan = userPlans[msg.sender][planId];\n        require(plan.active, \"No active plan\");\n        require(plan.user == msg.sender, \"Not plan owner\");\n\n        plan.active = false;\n        emit PlanCancelled(msg.sender, planId);\n    }\n\n    /**\n     * @notice Pause a SIP plan\n     */\n    function pausePlan(uint256 planId) external {\n        SIPPlan storage plan = userPlans[msg.sender][planId];\n        require(plan.active, \"No active plan\");\n        require(plan.user == msg.sender, \"Not plan owner\");\n        \n        plan.active = false;\n        emit PlanPaused(msg.sender, planId);\n    }\n\n    /**\n     * @notice Resume a paused SIP plan\n     */\n    function resumePlan(uint256 planId) external {\n        SIPPlan storage plan = userPlans[msg.sender][planId];\n        require(plan.createdAt > 0, \"Plan does not exist\");\n        require(plan.user == msg.sender, \"Not plan owner\");\n        require(!plan.active, \"Plan already active\");\n        \n        plan.active = true;\n        emit PlanResumed(msg.sender, planId);\n    }\n\n    /**\n     * @notice Update the SpendPermissionManager address\n     */\n    function setSpendPermissionManager(address _spendPermissionManager) external onlyOwner {\n        spendPermissionManager = ISpendPermissionManager(_spendPermissionManager);\n    }\n\n    /**\n     * @notice Set the expert agent address for AI payments\n     */\n    function setExpertAgentAddress(address _expertAgentAddress) external onlyOwner {\n        address oldAddress = expertAgentAddress;\n        expertAgentAddress = _expertAgentAddress;\n        emit ExpertAgentAddressUpdated(oldAddress, _expertAgentAddress);\n    }\n\n    /**\n     * @notice Transfer ownership\n     */\n    function transferOwnership(address newOwner) external onlyOwner {\n        require(newOwner != address(0), \"Invalid address\");\n        owner = newOwner;\n    }\n\n    receive() external payable {}\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}